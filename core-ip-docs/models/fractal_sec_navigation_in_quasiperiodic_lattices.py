# -*- coding: utf-8 -*-
"""Fractal SEC Navigation in Quasiperiodic Lattices

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1usPaieBfhWCTpJiDKKJqLC7b5Zvf1Pon
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import linalg
from scipy.ndimage import zoom
import warnings
warnings.filterwarnings('ignore')

# Constants from EVL theory
PHI = (1 + np.sqrt(5)) / 2  # Golden ratio
ALPHA_CRITICAL = PHI / (2 * np.pi)  # Critical flux for Ten Martini

def harper_hamiltonian(N, lambda_coupling, alpha):
    """Harper/Hofstadter Hamiltonian for quasiperiodic lattice"""
    H = np.zeros((N, N))
    for n in range(N):
        # Hopping terms
        H[n, (n+1)%N] = -1
        H[n, (n-1)%N] = -1
        # On-site quasiperiodic potential
        H[n, n] = 2 * lambda_coupling * np.cos(2 * np.pi * alpha * n)
    return H

def compute_spectrum_gaps(N_range, lambda_coupling, alpha):
    """Compute energy spectrum and identify gaps (Cantor set structure)"""
    all_energies = []
    for N in N_range:
        H = harper_hamiltonian(N, lambda_coupling, alpha)
        eigenvalues = linalg.eigvalsh(H)
        all_energies.extend(eigenvalues)

    all_energies = np.sort(all_energies)
    # Identify gaps
    diffs = np.diff(all_energies)
    gap_threshold = np.percentile(diffs, 90)
    gaps = diffs > gap_threshold

    return all_energies, gaps

def hausdorff_dimension(energies, box_sizes):
    """Estimate local Hausdorff dimension of spectrum"""
    counts = []
    for epsilon in box_sizes:
        boxes = len(energies) / epsilon
        non_empty = len(np.unique(np.floor(energies / epsilon)))
        counts.append(non_empty)

    # Linear fit in log-log space
    log_epsilon = np.log(box_sizes)
    log_counts = np.log(counts)
    D_H = -np.polyfit(log_epsilon, log_counts, 1)[0]
    return D_H

def sec_equation(O, V, eta):
    """System Entropy Change equation"""
    return (O * V) / (1 + eta)

def eta_fractal(position, spectrum, D_H, lambda_scale=1.0):
    """Positional energy multiplier with fractal scaling"""
    # Find nearest spectral features
    idx = np.searchsorted(spectrum, position)
    if idx == 0 or idx >= len(spectrum):
        local_density = 1.0
    else:
        local_density = 1.0 / (spectrum[idx] - spectrum[idx-1])

    # Scale by Hausdorff dimension
    eta = (local_density / lambda_scale) ** D_H
    return eta

def chaos_extension(SEC_base, alpha_chaos, omega, t):
    """Temporal chaos extension for SEC"""
    return SEC_base * (1 + alpha_chaos * np.sin(omega * t))

def visualize_fractal_navigation():
    """Main visualization of fractal SEC navigation"""
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))
    fig.suptitle('Fractal SEC Navigation in Quasiperiodic Lattices', fontsize=16)

    # 1. Compute spectrum at critical coupling
    N_range = range(20, 100, 10)
    lambda_coupling = 1.0  # Critical coupling for Cantor spectrum
    energies, gaps = compute_spectrum_gaps(N_range, lambda_coupling, ALPHA_CRITICAL)

    # 2. Estimate Hausdorff dimension
    box_sizes = np.logspace(-2, 0, 10)
    D_H = hausdorff_dimension(energies, box_sizes)

    # Plot 1: Energy spectrum (Cantor-like structure)
    ax = axes[0, 0]
    ax.scatter(energies, np.zeros_like(energies), s=1, alpha=0.5)
    ax.set_xlabel('Energy')
    ax.set_title(f'Quasiperiodic Spectrum (D_H ≈ {D_H:.2f})')
    ax.set_ylim(-0.1, 0.1)

    # Plot 2: SEC landscape across energy positions
    ax = axes[0, 1]
    positions = np.linspace(min(energies), max(energies), 200)
    O = 1.0  # Operation strength
    V = 1.0  # Intent vector magnitude

    sec_values = []
    eta_values = []
    for pos in positions:
        eta = eta_fractal(pos, energies, D_H)
        eta_values.append(eta)
        sec = sec_equation(O, V, eta)
        sec_values.append(sec)

    ax.plot(positions, sec_values)
    ax.set_xlabel('Energy Position')
    ax.set_ylabel('SEC')
    ax.set_title('SEC Navigation Capacity')

    # Plot 3: Positional energy multiplier η
    ax = axes[0, 2]
    ax.semilogy(positions, eta_values)
    ax.set_xlabel('Energy Position')
    ax.set_ylabel('η (log scale)')
    ax.set_title('Fractal Positional Energy Multiplier')

    # Plot 4: Hofstadter butterfly slice
    ax = axes[1, 0]
    alpha_range = np.linspace(0, 1, 50)
    lambda_range = np.linspace(0, 3, 50)
    spectrum_map = np.zeros((len(lambda_range), len(alpha_range)))

    for i, lam in enumerate(lambda_range):
        for j, alpha in enumerate(alpha_range):
            H = harper_hamiltonian(30, lam, alpha)
            eigvals = linalg.eigvalsh(H)
            spectrum_map[i, j] = np.std(eigvals)  # Spectral width as proxy

    im = ax.imshow(spectrum_map, extent=[0, 1, 0, 3], aspect='auto', origin='lower')
    ax.axvline(ALPHA_CRITICAL, color='red', linestyle='--', alpha=0.5, label='α = φ/2π')
    ax.set_xlabel('Flux α')
    ax.set_ylabel('Coupling λ')
    ax.set_title('Hofstadter Butterfly Region')
    ax.legend()

    # Plot 5: Chaos extension dynamics
    ax = axes[1, 1]
    t_range = np.linspace(0, 10, 1000)
    omega = 2 * np.pi

    for alpha_chaos in [0.1, 0.5, 1.0, 2.0]:
        sec_base = 0.5  # Baseline SEC
        sec_temporal = [chaos_extension(sec_base, alpha_chaos, omega, t) for t in t_range]
        ax.plot(t_range, sec_temporal, label=f'α_chaos = {alpha_chaos}')

    ax.set_xlabel('Time')
    ax.set_ylabel('SEC(t)')
    ax.set_title('Chaos Extension: Temporal SEC Dynamics')
    ax.legend()

    # Plot 6: Multi-scale SEC navigation
    ax = axes[1, 2]
    # Simulate zooming into fractal structure
    zoom_levels = [1, 2, 4, 8]
    colors = plt.cm.viridis(np.linspace(0, 1, len(zoom_levels)))

    for i, zoom_factor in enumerate(zoom_levels):
        zoomed_positions = positions[::zoom_factor][:50]
        zoomed_sec = sec_values[::zoom_factor][:50]
        ax.plot(zoomed_positions - zoomed_positions[0], zoomed_sec,
                color=colors[i], label=f'Zoom ×{zoom_factor}')

    ax.set_xlabel('Relative Position')
    ax.set_ylabel('SEC')
    ax.set_title('Self-Similar SEC Structure')
    ax.legend()

    plt.tight_layout()
    plt.show()

def analyze_critical_behavior():
    """Analyze SEC behavior near critical points"""
    print("Analyzing critical behavior at Ten Martini flux...")

    # Compare golden ratio flux vs rational approximants
    fluxes = [
        (ALPHA_CRITICAL, "φ/2π (golden)"),
        (0.5, "1/2 (rational)"),
        (0.618, "≈φ (approximate)"),
        (0.382, "1-φ/2 (conjugate)")
    ]

    N = 50
    lambda_coupling = 1.0

    for flux, label in fluxes:
        H = harper_hamiltonian(N, lambda_coupling, flux)
        eigvals = linalg.eigvalsh(H)

        # Compute gap statistics
        gaps = np.diff(np.sort(eigvals))
        mean_gap = np.mean(gaps)
        gap_variance = np.var(gaps)

        # Estimate effective SEC navigation difficulty
        avg_eta = np.mean([eta_fractal(e, eigvals, 1.5) for e in eigvals])
        avg_sec = sec_equation(1.0, 1.0, avg_eta)

        print(f"\n{label}:")
        print(f"  Mean gap: {mean_gap:.4f}")
        print(f"  Gap variance: {gap_variance:.4f}")
        print(f"  Average η: {avg_eta:.4f}")
        print(f"  Average SEC: {avg_sec:.4f}")

# Run the analysis
visualize_fractal_navigation()
analyze_critical_behavior()

# Additional analysis: SEC optimization in fractal landscape
def optimize_sec_path():
    """Find optimal path through fractal energy landscape with tunneling"""
    print("\n" + "="*50)
    print("SEC Path Optimization in Fractal Landscape")
    print("="*50)

    # Generate fine-grained spectrum
    N = 100
    H = harper_hamiltonian(N, 1.0, ALPHA_CRITICAL)
    spectrum = np.sort(linalg.eigvalsh(H))

    # Calculate mean gap for tunneling threshold
    gaps = np.diff(spectrum)
    mean_gap = np.mean(gaps)

    # Simulate navigation from lowest to highest energy
    start_idx, end_idx = 10, 90
    path_length = 20
    tunnel_probability = 0.1  # Probability of tunneling across large gaps

    # Greedy optimization: choose next position to maximize SEC
    current_pos = spectrum[start_idx]
    path = [current_pos]
    sec_trajectory = []
    tunneling_events = 0

    for step in range(path_length):
        # Find where we are in the spectrum
        current_idx = np.searchsorted(spectrum, current_pos)

        # Define local candidates around current position
        local_start = max(0, current_idx - 5)
        local_end = min(len(spectrum), current_idx + 5)
        local_candidates = spectrum[local_start:local_end]

        # Find gap positions for potential tunneling
        gap_positions = np.where(gaps > mean_gap * 2)[0]

        # Combine candidates
        if len(gap_positions) > 0:
            tunnel_candidates = spectrum[gap_positions]
            candidates = np.concatenate([local_candidates, tunnel_candidates])
        else:
            candidates = local_candidates

        best_sec = -np.inf
        best_next = current_pos
        used_tunneling = False

        for next_pos in candidates:  # Check all candidates, not sampled
            if abs(next_pos - current_pos) > 0.0001:  # Avoid staying in same spot
                eta = eta_fractal(next_pos, spectrum, 1.5)
                distance = abs(next_pos - current_pos)

                # Check if we should consider tunneling for large gaps
                if distance > mean_gap * 2:
                    if np.random.random() < tunnel_probability:
                        eta *= 0.1  # Reduce effective barrier for tunneling
                        used_tunneling = True

                # Intent decreases with distance
                V = 1.0 / (1 + distance)
                sec = sec_equation(1.0, V, eta)

                if sec > best_sec:
                    best_sec = sec
                    best_next = next_pos

        if used_tunneling and best_next != current_pos:
            tunneling_events += 1

        current_pos = best_next
        path.append(current_pos)
        sec_trajectory.append(best_sec)

    print(f"Optimal path found with {len(path)} steps")
    print(f"Average SEC along path: {np.mean(sec_trajectory):.4f}")
    print(f"SEC variance: {np.var(sec_trajectory):.4f}")
    print(f"Tunneling events: {tunneling_events}")

    # Also compute path without tunneling for comparison
    print("\nComparison with no-tunneling path:")
    current_pos = spectrum[start_idx]
    path_no_tunnel = [current_pos]
    sec_no_tunnel = []

    for step in range(path_length):
        candidates = spectrum[start_idx:end_idx]
        best_sec = -np.inf
        best_next = current_pos

        for next_pos in candidates[::5]:
            if abs(next_pos - current_pos) > 0.0001:
                eta = eta_fractal(next_pos, spectrum, 1.5)
                distance = abs(next_pos - current_pos)
                V = 1.0 / (1 + distance)
                sec = sec_equation(1.0, V, eta)

                if sec > best_sec:
                    best_sec = sec
                    best_next = next_pos

        current_pos = best_next
        path_no_tunnel.append(current_pos)
        sec_no_tunnel.append(best_sec)

    print(f"No-tunneling average SEC: {np.mean(sec_no_tunnel):.4f}")
    print(f"No-tunneling SEC variance: {np.var(sec_no_tunnel):.4f}")

    return path, sec_trajectory

optimal_path, sec_values = optimize_sec_path()